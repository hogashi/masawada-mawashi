using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class mawashi__namei__ : MonoBehaviour
{
  // individual number
  int number = __numberi__;
  Vector2 goal;
  int goalY;
  float phase;
  float phaseDiffY;
  float dpi;
  float weakenNumber;
  float weakenPeriod;
  float angleAtPeriod;
  float goalTime;
  int isParade;

  // Start is called before the first frame update
  void Start()
  {
    // 定数
    // 2 \pi
    dpi = 2.0f * Mathf.PI;
    // 連番は6まであって6倍は効きすぎるので弱める
    weakenNumber = 3.0f;
    // 幅や高さで割ることで端から端までの周期を同じにするが,
    // 幅や高さは数百あるので弱めて周期を減らす
    weakenPeriod = 3.0f;
    // 連番1が1周期で何度回るか(連番次第で回転数は上がる)
    angleAtPeriod = 360.0f;

    // ゴール座標は毎回違うけど6人全員同じにするために,
    // マウス位置を乱数シードにする
    int initX = (int)(
      Camera.main.ScreenToWorldPoint(Input.mousePosition).x * 100.0f
    );
    Random.InitState(initX);
    // これより端にゴールを設定しない
    int padding = 15;
    goal = new Vector2(
      (int)(Random.Range(padding, Screen.width - padding)),
      (int)(Random.Range(padding, Screen.height - padding))
    );
    Debug.Log("goal : " + goal.x + ", " + goal.y + " : screen : " + Screen.width + ", " + Screen.height);

    // 位相のずれは毎回かつ人によって違うものにするために,
    // マウス位置と連番の和を乱数シードにする
    Random.InitState(initX + number);
    phase = Random.Range(0, dpi);
    phaseDiffY = Mathf.Sin(phase);
    float xOfSin = phase;
    goalY = getY(xOfSin);

    // 最初にゴールした時間
    goalTime = 0.0f;
  }

  // Update is called once per frame
  void Update()
  {
    if (isParade == 1) {
      parade();
      return;
    }

    Vector3 pos = Input.mousePosition;
    pos.x = (int)pos.x;
    pos.y = (int)pos.y;

    // ゴールで前を向くために,
    // ゴールにたどり着いたら0になるように引き算をする
    // 連番の大小の効きはX,Yで逆にする
    float ingrediantX =
      ((float)number / weakenNumber) * (pos.x - goal.x)
      / (Screen.width * weakenPeriod);
    float ingrediantY =
      ((float)(7 - number) / weakenNumber) * (pos.y - goal.y)
      / (Screen.height * weakenPeriod);

    float xOfSin =
      (ingrediantX + ingrediantY) * dpi + phase;
    int newY = getY(xOfSin);

    transform.rotation = Quaternion.Euler(0, newY, 0);
    Debug.Log("goal: " + goal.x + ", " + goal.y + " :pos: " + pos.x + ", " + pos.y + " :y: " + goalY + ", " + newY);

    checkIsGoal(pos, newY);
  }

  int getY(float x) {
    // 連番次第で回転数を上げる(6倍は効きすぎるので弱める)
    // 最低でも1回転はするために,最後に1を足す(気持ち程度に弱める前に1引く)
    float multiplyAngleAtPeriod = (number - 1.0f) / weakenNumber + 1.0f;
    // あまりにシビアだとクリアできないので,回転角の解像度を落とす
    float resolution = 12.0f;
    // 周期をずらした分だけYも0からずれるので,0補正する
    return (int)(
      (
        (Mathf.Sin(x) - phaseDiffY)
        * angleAtPeriod * multiplyAngleAtPeriod
      ) / resolution
    ) * ((int)resolution) + 180;  // 180: 前
  }

  void parade() {
    int paradeTime = (int)(Time.time - goalTime);

    if (paradeTime > 4 && number == 1) {
      // 4秒パレードしたら連番1がタイトルに戻す
      SceneManager.LoadScene("title");
    } else if ((paradeTime % 2) == 1) {
      makeMasawadaNormal();
    } else {
      makeMasawadaGreatAgain();
    }
  }

  void checkIsGoal(Vector3 pos, int y) {
    float time = Time.time;

    int isNearGoal = 0;
    int goalWindow = 2;
    if (Mathf.Abs(pos.x - goal.x) < goalWindow && Mathf.Abs(pos.y - goal.y) < goalWindow) {
      isNearGoal = 1;
    }

    if (y == 180 && isNearGoal == 1) {
      if (goalTime == 0) {
        goalTime = time;
        makeMasawadaGreatAgain();
      } else {
        // 0.5秒間ゴールし続けられたらパレード開催
        if (time - goalTime > 0.5f) {
          isParade = 1;
        }
      }
    } else {
      goalTime = 0.0f;
      makeMasawadaNormal();
    }
  }

  void makeMasawadaGreatAgain() {}
  void makeMasawadaNormal() {}
}
